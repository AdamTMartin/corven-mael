// scripts/fetch-sheet.mjs
import fs from "node:fs/promises";
import path from "node:path";

const SHEET_CSV_URL =
  process.env.SHEET_CSV_URL ||
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vQQVqt0j8dQI6IHPFMGwyNHMzDdd-mGfgPGAPTrJ47DoZryFJMR97wL48ALjABkv0CpRHnXhQk-ims1/pub?gid=0&single=true&output=csv";

// "sheet_wins" (default) or "repo_wins"
const MERGE_MODE = (process.env.MERGE_MODE || "sheet_wins").toLowerCase();

const DATA_FILE = path.join("data", "data.js");

function parseCSV(text) {
  // Minimal CSV parser that preserves quoted newlines
  const rows = [];
  let i = 0, field = "", row = [], inQuotes = false;
  while (i < text.length) {
    const c = text[i], n = text[i+1];
    if (inQuotes) {
      if (c === '"' && n === '"') { field += '"'; i += 2; continue; }
      if (c === '"') { inQuotes = false; i++; continue; }
      field += c; i++; continue;
    }
    if (c === '"') { inQuotes = true; i++; continue; }
    if (c === ',') { row.push(field); field = ""; i++; continue; }
    if (c === '\r') { i++; continue; }
    if (c === '\n') { row.push(field); rows.push(row); row = []; field = ""; i++; continue; }
    field += c; i++;
  }
  row.push(field); rows.push(row);
  return rows;
}

function rowsToRecords(rows) {
  const [header, ...data] = rows;
  if (!header) return [];
  const idx = Object.fromEntries(header.map((h,i)=>[h, i]));
  const get = (r, k) => (r[idx[k]] ?? "").toString();

  const normalize = (r) => {
    const slug = get(r,"slug").trim();
    if (!slug) return null;
    const title = (get(r,"title").trim() || "(untitled)");
    const type = (get(r,"type").trim() || "Note");
    const summary = get(r,"summary").trim();
    const date = get(r,"date").trim();
    const tags = get(r,"tags").split(",").map(s=>s.trim()).filter(Boolean);
    const body = get(r,"body");

    const rec = { slug, type, title };
    if (summary) rec.summary = summary;
    if (date) rec.date = date;
    if (tags.length) rec.tags = tags;
    if (body) rec.body = body;
    return rec;
  };

  return data.map(normalize).filter(Boolean);
}

async function readExistingDataJs() {
  try {
    const raw = await fs.readFile(DATA_FILE, "utf8");
    const m = raw.match(/window\.CORVEN_DATA\s*=\s*(\[[\s\S]*?\]);?\s*$/m);
    if (!m) return [];
    return JSON.parse(m[1]);
  } catch {
    return [];
  }
}

function mergeRecords(existingArr, incomingArr, mode = "sheet_wins") {
  const bySlug = new Map(existingArr.map(r => [r.slug, r]));

  const nonEmpty = (v) => v !== undefined && v !== null && !(typeof v === "string" && v.trim() === "");

  for (const inc of incomingArr) {
    const cur = bySlug.get(inc.slug);
    if (!cur) {
      bySlug.set(inc.slug, inc);
      continue;
    }
    // Merge strategy
    const winnerFirst = mode === "sheet_wins" ? [inc, cur] : [cur, inc];
    const [primary, secondary] = winnerFirst;

    const merged = { ...secondary, ...primary }; // winner fields first
    // Special handling: tags = union
    const tags = new Set([...(secondary.tags || []), ...(primary.tags || [])]);
    if (tags.size) merged.tags = [...tags];

    // Only overwrite fields with non-empty values from primary
    for (const k of ["title","type","summary","date","body"]) {
      if (!nonEmpty(primary[k]) && nonEmpty(secondary[k])) merged[k] = secondary[k];
    }

    bySlug.set(inc.slug, merged);
  }

  // Return sorted: date desc, then title
  const out = [...bySlug.values()].sort((a,b)=>{
    const da = a.date ? Date.parse(a.date) : 0;
    const db = b.date ? Date.parse(b.date) : 0;
    if (db !== da) return db - da;
    return (a.title || "").localeCompare(b.title || "");
  });

  return out;
}

(async function main(){
  const res = await fetch(SHEET_CSV_URL);
  if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
  const csv = await res.text();
  const rows = parseCSV(csv);
  const incoming = rowsToRecords(rows);

  const existing = await readExistingDataJs();
  const merged = mergeRecords(existing, incoming, MERGE_MODE);

  const out = `// GENERATED by sheet sync (merge mode: ${MERGE_MODE}).\n` +
              `// Source: ${SHEET_CSV_URL}\n` +
              `window.CORVEN_DATA = ${JSON.stringify(merged, null, 2)};\n`;

  await fs.mkdir(path.dirname(DATA_FILE), { recursive: true });
  await fs.writeFile(DATA_FILE, out, "utf8");
  console.log(`Merged ${incoming.length} sheet rows with ${existing.length} existing â†’ wrote ${merged.length} entries`);
})().catch((e)=>{ console.error(e); process.exit(1); });
